.. _tutorial_package_layout:

Understanding the Conan Package layout
======================================

.. _developing_packages_layout:

In the previous section, we introduced the concept of *editable packages* and mentioned
that the reason they work *out of the box* when put in editable mode is due to the current
definition of the information in the ``layout()`` method. Let's examine this feature in
more detail.

在前面的部分中，我们介绍了 *可编辑包* 的概念，并提到了当将它们放在可编辑模式中时，
它们可以立即工作的原因是因为当前在 ``layout()`` 方法中定义了信息。让我们更详细地研究一下这个特性。

In this tutorial, we will continue working with the ``say/1.0`` package and the
``hello/1.0`` consumer used in the :ref:`editable packages <editable_packages>` tutorial.

在本教程中，我们将继续使用 ``say/1.0`` 包和 :ref:`editable packages <editable_packages>`  教程中使用的 ``hello/1.0`` 使用者。

Please, first of all, clone the sources to recreate this project. You can find them in the
`examples2.0 repository <https://github.com/conan-io/examples2>`_ in GitHub:

.. code-block:: bash

    $ git clone https://github.com/conan-io/examples2.git
    $ cd examples2/tutorial/developing_packages/package_layout

.. include:: ../cmake_presets_note.inc

As you can see, the main folder structure is the same: 

..  code-block:: text

    .
    ├── hello
    │   ├── CMakeLists.txt
    │   ├── conanfile.py
    │   └── src
    │       └── hello.cpp
    └── say
        ├── CMakeLists.txt
        ├── conanfile.py
        ├── include
        │   └── say.h
        └── src
            └── say.cpp


The main difference here is that we are not using the predefined
:ref:`cmake_layout()<cmake_layout>` in the ``say/1.0`` ConanFile, but instead, we are
declaring our own custom layout. Let's see how we describe the information in the
``layout()`` method so that it works both when we create the package in the Conan local
cache and also when the package is in editable mode.

这里的主要区别在于，我们没有在 ``say/1.0`` ConanFile 中使用预定义的 :ref:`cmake_layout()<cmake_layout>` ，
而是声明了我们自己的定制布局。让我们看看如何描述 ``layout()`` 方法中的信息，以便在 Conan 本地缓存中创建包时
以及在包处于可编辑模式时都能正常工作。

..  code-block:: python
    :caption: say/conanfile.py

    import os
    from conan import ConanFile
    from conan.tools.cmake import CMake


    class SayConan(ConanFile):
        name = "say"
        version = "1.0"

        exports_sources = "CMakeLists.txt", "src/*", "include/*"

        ...

        def layout(self):

            ## define project folder structure

            self.folders.source = "."
            self.folders.build = os.path.join("build", str(self.settings.build_type))
            self.folders.generators = os.path.join(self.folders.build, "generators")

            ## cpp.package information is for consumers to find the package contents in the Conan cache

            self.cpp.package.libs = ["say"]
            self.cpp.package.includedirs = ["include"] # includedirs is already set to 'include' by
                                                       # default, but declared for completion
            self.cpp.package.libdirs = ["lib"]         # libdirs is already set to 'lib' by
                                                       # default, but declared for completion

            ## cpp.source and cpp.build information is specifically designed for editable packages:

            # this information is relative to the source folder that is '.'
            self.cpp.source.includedirs = ["include"] # maps to ./include

            # this information is relative to the build folder that is './build/<build_type>', so it will 
            self.cpp.build.libdirs = ["."]  # map to ./build/<build_type> for libdirs

        def build(self):
            cmake = CMake(self)
            cmake.configure()
            cmake.build()


Let's review the ``layout()`` method. You can see that we are setting values for
``self.folders`` and ``self.cpp``. Let's explain what these values do.

让我们回顾 ``layout()`` 方法。您可以看到，我们正在为 ``self.folders`` 和 ``self.cpp`` 设置值。让我们来解释一下这些值的作用。

self.folders
------------

Defines the structure of the ``say`` project for the source code and the folders where the
files generated by Conan and the built artifacts will be located. This structure is
independent of whether the package is in editable mode or exported and built in the Conan
local cache. Let's define the folder structure for the ``say`` package:

为源代码和文件夹定义 ``say`` 项目的结构，Conan 生成的文件和构建的构件将位于这些文件夹中。
此结构与包是处于可编辑模式还是导出并在 Conan 本地缓存中构建无关。让我们定义 ``say`` 
包的文件夹结构:

..  code-block:: text

     say
      ├── CMakeLists.txt
      ├── conanfile.py
      ├── include
      │   └── say.h
      ├── src
      │   └── say.cpp
      └── build
          ├── Debug            --> Built artifacts for Debug
          │   └── generators   --> Conan generated files for Debug config
          └── Release          --> Built artifacts for Release
              └── generators   --> Conan generated files for Release config


- As we have our ``CMakeLists.txt`` in the ``.`` folder, ``self.folders.source`` is set to
  ``.``.

  因为 ``.`` 文件夹中有 ``CMakeLists.txt``，所以 ``self.folders.source`` 被设置为 ``.`` 。

- We set ``self.folders.build`` to be **./build/Release** or **./build/Debug** depending
  on the ``build_type`` setting. These are the folders where we want the built binaries to
  be located. 

  我们设置 ``self.folders.build`` 为 **./build/Release** 或 **./build/Debug** 取决于 ``build_type`` 设置。
  这些是我们希望生成的二进制文件所在的文件夹。

- The ``self.folders.generators`` folder is the location we set for all the files created
  by the Conan generators. In this case, all the files generated by the ``CMakeToolchain``
  generator will be stored there.

  ``self.folders.generators`` 文件夹是我们为 Conan 生成器创建的所有文件设置的位置。
  在这种情况下， ``CMakeToolchain`` 生成器生成的所有文件都将存储在那里。

.. note::

    Please note that the values above are for a single-configuration CMake generator. To
    support multi-configuration generators, such as Visual Studio, you should make some
    changes to this layout. For a complete layout that supports both single-config and
    multi-config, please check the :ref:`cmake_layout()<cmake_layout>` in the Conan
    documentation.

    请注意，上面的值适用于单配置 CMake 生成器。若要支持多配置生成器(如 VisualStudio) ，
    应对此布局进行一些更改。要获得同时支持单配置和多配置的完整布局，请查看 Conan 文档中的 
    :ref:`cmake_layout()<cmake_layout>`。

self.cpp
--------

This attribute is used to define **where consumers will find the package contents**
(headers files, libraries, etc.) depending on whether the package is in editable mode or
not.

此属性用于定义 **使用者将在何处找到包内容** (头文件、库等) ，具体取决于包是否处于可编辑模式。

cpp.package
^^^^^^^^^^^

First, we set the information for `cpp.package`. This defines the contents of the package
and its location relative to the folder where the package is stored in the local cache.
Please note that defining this information is equivalent to defining `self.cpp_info` in
the `package_info()` method. This is the information we defined:

首先，我们为 `cpp.package` 设置信息。这将定义包的内容及其相对于包存储在本地缓存中的文件夹的位置。
请注意，定义此信息等同于在 `package_info()` 方法中定义 `self.cpp_info`。这是我们定义的信息:

- ``self.cpp.package.libs``: we add the ``say`` library so that consumers know that they
  should link with it. This is equivalent to declaring ``self.cpp_info.libs`` in the
  ``package_info()`` method.

  我们添加 ``say`` 库，这样消费者就知道他们应该与之链接。这相当于声明 ``package_info()`` 
  方法中的 ``self.cpp_info.libs``。

- ``self.cpp.package.libdirs``: we add the ``lib`` folder so that consumers know that they
  should search there for the libraries. This is equivalent to declaring
  ``self.cpp_info.libdirs`` in the ``package_info()`` method. Note that the default value
  for ``libdirs`` in both the ``cpp_info`` and ``cpp.package`` is ``["lib"]`` so we could
  have omitted that declaration.

  我们添加了 ``lib`` 文件夹，这样用户就知道他们应该在那里搜索库。这相当于声明 ``package_info()``
  方法中的  ``self.cpp_info.libdirs``。注意， ``cpp_info`` 和 ``cpp.package`` 中 ``libdirs`` 
  的默认值都是 ``["lib"]`` ，所以我们可以省略这个声明。

- ``self.cpp.package.includedirs``: we add the ``include`` folder so that consumers know
  that they should search there for the library headers. This is equivalent to
  declaring ``self.cpp_info.includedirs`` in the ``package_info()`` method. Note that the
  default value for ``includedirs`` in both the ``cpp_info`` and ``cpp.package`` is
  ``["include"]`` so we could have omitted that declaration.

  我们添加了 ``include`` 文件夹，这样用户就知道他们应该在那里搜索库标题。
  这相当于声明 ``package_info()`` 方法中的 ``self.cpp_info.includedirs``。注意， 
  ``cpp_info`` 和 ``cpp.package`` 中的 ``includedirs`` 的默认值都是 ``["include"]`` ，
  所以我们可以省略这个声明。

To check how this information affects consumers we are going to do first do a ``conan create`` on
the ``say`` package:

为了检查这些信息是如何影响消费者的，我们首先在 ``say`` 包上做一个 ``conan create``:

.. code-block:: bash

    $ cd say
    $ conan create . -s build_type=Release

When we call ``conan create``, Conan moves the recipe and sources declared in the recipe
to be exported to the local Cache to a recipe folder and after that, it will create a
separate package folder to build the binaries and store the actual package contents. If
you check in the ``[YOUR_CONAN_HOME]/p`` folder, you will find two new folders similar to
these:

当我们调用 ``conan create`` 时，Conan 会将配方中声明的配方和源代码导出到本地 Cache 
中的配方文件夹，然后，它会创建一个单独的包文件夹来构建二进制文件并存储实际的包内容。
如果您检查 ``[YOUR_CONAN_HOME]/p`` 文件夹，您将找到两个类似的新文件夹: 

.. tip::

    You could get the exact locations for this folders using the :command:`conan cache`
    command or checking the output of the :command:`conan create` command.

    您可以使用  :command:`conan cache` 命令或检查 :command:`conan create`  命令的输出来获得这些文件夹的确切位置。

.. code-block:: text
    :emphasize-lines: 14-18

    <YOUR_CONAN_HOME>/p
    ├── sayb3ea744527a91      --> folder for sources
    │   └── ...
    │
    └── say830097e941e10      --> folder for building and storing the package binaries
        ├── b
        │   ├── build
        │   │   └── Release
        │   ├── include
        │   │   └── say.h
        │   └── src
        │       ├── hello.cpp
        │       └── say.cpp
        └── p
            ├── include       --> defined in cpp.package.includedirs
            │   └── say.h
            └── lib           --> defined in cpp.package.libdirs
                └── libsay.a  --> defined in self.cpp.package.libs

You can identify there the structure we defined in the ``layout()`` method. If you build
the ``hello`` consumer project now, it will search for all the headers and libraries of
``say`` in that folder inside the local Cache in the locations defined by ``cpp.package``:

您可以在那里标识我们在 ``layout()`` 方法中定义的结构。如果您现在构建  ``hello``  Consumer 项目，
它将在 ``cpp.package`` 定义的位置搜索本地 Cache 中该文件夹中的所有标头和库 ``say``:

.. code-block:: bash
    :emphasize-lines: 13, 11

    $ cd ../hello
    $ conan install . -s build_type=Release

    # Linux, MacOS
    $ cmake --preset conan-release --log-level=VERBOSE
    # Windows
    $ cmake --preset conan-default --log-level=VERBOSE

    ...
    -- Conan: Target declared 'say::say'
    -- Conan: Library say found <YOUR_CONAN_HOME>p/say8938ceae216fc/p/lib/libsay.a
    -- Created target CONAN_LIB::say_say_RELEASE STATIC IMPORTED
    -- Conan: Found: <YOUR_CONAN_HOME>p/p/say8938ceae216fc/p/lib/libsay.a
    -- Configuring done
    ...

    $ cmake --build --preset conan-release
    [ 50%] Building CXX object CMakeFiles/hello.dir/src/hello.cpp.o
    [100%] Linking CXX executable hello
    [100%] Built target hello


cpp.source and cpp.build
^^^^^^^^^^^^^^^^^^^^^^^^

We also defined ``cpp.source`` and ``cpp.build`` attributes in our recipe. These are only
used when the package is in editable mode and point to the locations that consumers will
use to find headers and binaries. We defined:

我们还在配方中定义了 ``cpp.source`` 和 ``cpp.build`` 属性。只有在包处于可编辑模式并
指向消费者将用于查找头文件和二进制文件的位置时，才会使用这些选项。我们定义:

- ``self.cpp.source.includedirs`` set to ``["include"]``. This location is relative to the
  ``self.folders.source`` that we defined to ``.``. In the case of editable packages, this
  location will be the local folder where we have our project.

  ``self.cpp.source.includedirs`` 目录设置为 ``["include"]``。这个位置是相对于我们定义的 
  ``self.folders.source`` 的 ``.``。在可编辑包的情况下，这个位置将是我们的项目所在的本地文件夹。

- ``self.cpp.build.libdirs`` set to ``["."]``. This location is relative to the
  ``self.folders.build`` that we defined to **./build/<build_type>**. In the case of
  editable packages, this location will point to **<local_folder>/build/<build_type>**.

  ``self.cpp.build.libdirs`` 设置为 ``["."]``.这个位置是相对于我们定义的 ``self.folders.build``  
  的 **./build/<build_type>**。对于可编辑包，此位置将指向  **<local_folder>/build/<build_type>**。
  
To check how this information affects consumers, we are going to first put the ``say``
package in editable mode and build it locally.

为了检查这些信息如何影响消费者，我们首先将 ``say`` 包放在可编辑模式下，并在本地构建它。

.. code-block:: bash

    $ cd ../say
    $ conan editable add . --name=say --version=1.0
    $ conan install . -s build_type=Release
    $ cmake --preset conan-release
    $ cmake --build --preset conan-release

You can check the contents of the say project's folder now, you can see that the output
folders match the ones we defined with ``self.folders``:

现在你可以检查 say 项目文件夹的内容了，你可以看到输出文件夹与我们定义的 ``self.folders`` 相匹配:

.. code-block:: text
    :emphasize-lines: 5,11,13

    .
    ├── CMakeLists.txt
    ├── CMakeUserPresets.json
    ├── build
    │   └── Release       --> defined in cpp.build.libdirs
    │       ├── ...
    │       ├── generators
    │       │   ├── CMakePresets.json
    │       │   ├── ...
    │       │   └── deactivate_conanrun.sh
    │       └── libsay.a  --> no need to define
    ├── conanfile.py
    ├── include           --> defined in cpp.source.includedirs
    │   └── say.h
    └── src
        ├── hello.cpp
        └── say.cpp

Now that we have the ``say`` package in editable mode, if we build the ``hello`` consumer
project, it will search for all the headers and libraries of ``say`` in the folders
defined by ``cpp.source`` and ``cpp.build``:

现在我们已经有了可编辑模式下的 ``say`` 包，如果我们构建  ``hello`` Consumer 项目，
它将在 ``cpp.source`` 和 ``cpp.build`` 定义的文件夹中搜索 ``say`` 的所有头和库:

.. code-block:: bash
    :emphasize-lines: 11-12

    $ cd ../hello
    $ conan install . -s build_type=Release

    # Linux, MacOS
    $ cmake --preset conan-release --log-level=VERBOSE
    # Windows
    $ cmake --preset conan-default --log-level=VERBOSE

    ...
    -- Conan: Target declared 'say::say'
    -- Conan: Library say found <local_folder>/examples2/tutorial/developing_packages/package_layout/say/build/Release/libsay.a
    -- Conan: Found: <local_folder>/examples2/tutorial/developing_packages/package_layout/say/build/Release/libsay.a
    -- Configuring done
    ...

    $ cmake --build --preset conan-release
    [ 50%] Building CXX object CMakeFiles/hello.dir/src/hello.cpp.o
    [100%] Linking CXX executable hello
    [100%] Built target hello

    $ conan editable remove --refs=say/1.0


.. note:: 

    Please, note that we did not define ``self.cpp.build.libs = ["say"]``. This is because
    the information set in ``self.cpp.source`` and ``self.cpp.build`` will be merged with
    the information set in ``self.cpp.package`` so that you only have to define things
    that change for the editable package. For the same reason, you could also omit setting
    ``self.cpp.source.includedirs = ["include"]`` but we left it there to show the use of
    ``cpp.source``. 

    请注意，我们没有定义 ``self.cpp.build.libs = ["say"]`` 。这是因为 ``self.cpp.source`` 和 
    ``self.cpp.build`` 中的信息集将与 ``self.cpp.package`` 中的信息集合在一起，
    这样您只需要为可编辑包定义更改的内容。出于同样的原因，您也可以省略设置 
    ``self.cpp.source.includedirs = ["include"]`` ， 但是我们把它留在那里是为了显示 
    ``cpp.source`` 的用法。

.. seealso::
    
    - Define the layout() :ref:`when you package third-party libraries<examples_conanfile_layout_third_party_libraries>`
    - Define the layout() :ref:`when you have the conanfile in a subfolder<examples_conanfile_layout_conanfile_in_subfolder>`
    - Define the layout() :ref:`when you want to handle multiple subprojects<examples_conanfile_layout_multiple_subprojects>`



